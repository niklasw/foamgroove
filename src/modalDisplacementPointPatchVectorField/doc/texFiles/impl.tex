\section{Implementation} \label{sec:impl}

The selection of implementation method is based on that the model should be
useful together
with any solver application supporting a dynamicFvMesh without changes to the
application. The application of the model should be specific to the OpenFOAM
case, not to the solver. Further, the user interface to the model should be
comprehendible, and not limited to a predefined number of modes.

Therefore the entire modal analysis model is implemented as a separate class,
that can be dynamically linked at runtime by the \texttt{libs ("library.so")}
directive in \texttt{system/controlDict}. Since the solid structure is
associated with fluid boundaries, the model is implemented as a boundary
condition and since the structural modes are associated with boundary
displacement, the boundary condition is a certain kind of point displacement
boundary condition.

\subsection{The modalDisplacement boundary condition}

The boundary condition serves to calculate and set point displacement vectors
for the patch points at each time step, based on fluid load and mode shapes
achieved from a modal analysis.

Thus, the following steps must be handled:

\begin{enumerate}
    \item Read mode shapes from modal analysis.
    \item If parallel: Distribute mode shapes to processors.
    \item Calculate the forcing term, $Q_i$ for each mode.
    \item Solve the ODE for mode coefficients, $\alpha_i$.
    \item Apply the resulting displacements to patch points.
\end{enumerate}

To achieve this, the boundary condition consists of two parts; The boundary
condition class itself, and an object handling the modes data and related calculations.
The boundary condition class constructs the structural modes,
when the boundary condition is constructed.

\subsubsection{The structuralModes class}

The class handling all modes calculations, is actually two classes: (1) A
\texttt{structuralMode} class, that manages reading and calculations of a
single mode and (2) a kind of a \texttt{List} class, \texttt{structuralModes},
that manages automatic construction of any number of \texttt{structuralMode}
objects, read from a dictionary and that has wrapper functions, calling
functions from each of its objects.  The implementation is borrowed from
e.g.~the implementation of porous zones.

The boundary condition, \texttt{modalDisplacement}, thus constructs its own
\texttt{structuralModes} list object, which in turn fills it self with all modes
defined in the associated dictionary. When the boundary condition is scheduled for
update (each time step), the boundary condition asks its structuralModes object
for the current point displacements and applies these.

\subsubsection{Parallelisation}

A mode shape from the modal analysis, needed to create a
\texttt{structuralMode}, consists of a list of vectors. Each vector in the list
corresponds to the displacement of a point in the moving patch and the vector list
has the same length as the number of points in the corresponding patch.
Specifically, the vector list corresponds to the the points of the patch in the
\emph{serical} case. Therefore, for parallel runs, the mode information must be
carefully distributed to each process. This is managed by the boundary condition,
which includes tables and functions that maps serial point labels to parallel
counterparts and vice versa.

To enable the construction of the label maps, the pre-processing step must include
generation of a file, containg a list of the serial case patch point labels.
An application is written to create this file.



\subsection{Usage of the modalDisplacement boundary condition}

First of all, a solver that implements a \texttt{dynamicFvMesh} is needed.
E.g.~pimpleDyMFoam or interDyMFoam. The dynamicFvMesh requires two case files:

\begin{itemize}
    \item A point field, \texttt{pointDisplacement}.
    \item A dictionary, \texttt{constant/dynamicMeshDict}, defining the
          motion solver to be used (standard to dynamic mesh codes).
\end{itemize}

Both of the above are commonly found in the tutorials and are not specific to the
modalDisplacement boundary condition.

Secondly, and unique to the present implementation, is the dicitonaries and
boundary condition definition needed for the modalDisplacement boundary
condition. The dictionaries are all stored in the directory
\texttt{constant/structuralModes/}, and consist of the following:

\begin{itemize}
    \item \texttt{fluidProperties}: Defines fluid density, since the solver might be incompressible.
    \item \texttt{modeData\_<patchName>}: Contains definition of each structural mode.
    \item \texttt{labels\_<patchName>}: A list of the serial point labels for the patch. This file is
        generated by the \texttt{writePatchPointLabels} utility.
    \item \texttt{monitorPoints\_<patchName>}: An optional list of point coordinates, which
        displacements are reported on standard output.
\end{itemize}

The \texttt{modeData\_\ldots} dictionary consists of a list of sub-dictionaries. Each describing
one structural mode. For a simulation including two modes only, it has the following form (excluding the header):

\begin{verbatim}
...
2
(
    first
    {
        generateMode no;
        frequency     10;
        scalingFactor 1;
        modeDisplacement
        #include "firstModeDisplacements.dat"
    }

    second
    {
        generateMode yes;
        generatedMode
        {
            origin  (0 0 0);
            axis    (0 0 1);
            waveLength   0.5;
            amplitude (0.05 0 0);
        }

        frequency     25;
        scalingFactor 1;
        modeDisplacement 0();
    }
)
\end{verbatim}

The first mode shape is based on existing data residing in the file \texttt{firstModeDisplacements.dat}.
This data file contains a vectorField with displacements corresponding to the patch points. The second
mode examplifies the posibility to let the boundary condition generate a mode. Presently this mode is
a simple trigonometric function, suitable for beams.
