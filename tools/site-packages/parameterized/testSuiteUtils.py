#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os,sys,glob,re

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class Borg:
    '''Hivemind base class. Google "python borg singleton" '''
    _shared_state = {}
    def __init__(self):
        self.__dict__ = self._shared_state

class Paths(Borg):
    '''By subclassing Borg, this class variables are common to
    all instances of Path(), in the main process.
    Note that Paths try to convert all paths to realpaths.

    Should perhaps make all classes that use configuration generated
    in Paths inherit Borg as well, which should make configuration
    builtin...
    '''
    SubCasePrefix = 'subCase_'
    SubCasePattern= SubCasePrefix+'.*'

    def __init__(self,testRoot=None,presentRoot=None,noCheck=False):
        '''First instance of this class must define the paths, then Paths
        can then be instantiated without arguments; Thus the kwargs None
        and the if statements below'''
        Borg.__init__(self)
        if testRoot:
            self.TestRoot = os.path.realpath(testRoot) # Top level test root
        if presentRoot:
            self.PresentRoot = os.path.realpath(presentRoot) # Top level presentation root
        if not self.__dict__.has_key('RunRoot'):
            self.RunRoot = os.getcwd()
        if not self.__dict__.has_key('SkipPresentation'):
            self.SkipPresentation = False
        if not self.__dict__.has_key('SkipRun'):
            self.SkipRun = False
        if not self.__dict__.has_key('DeleteSubCases'):
            self.DeleteSubCases = True
        if not self.__dict__.has_key('nThreads'):
            self.nThreads = 1
        if not self.__dict__.has_key('Debug'):
            self.Debug = False
        if not self.__dict__.has_key('NoCheck'):
            self.NoCheck = noCheck
        if not self.__dict__.has_key('MaxSizeParseableFile'):
            self.MaxSizeParseableFile = 10000000

        if not self.NoCheck:
            self.assertRoots()

    def assertRoots(self):
        def checkRoot(root):
            try:
                attribute = getattr(self,root)
                if not os.path.isdir(self.TestRoot):
                    Error('{0} does not exist: {1}'.format(root,attribute))
            except(AttributeError):
                Error('Missing path in Paths: {0}'.format(root))

        checkRoot('TestRoot')
        if not self.SkipPresentation:
            checkRoot('PresentRoot')
            if os.path.isdir(self.PresentRoot):
                Warning('PresentRoot exists, do you want to mess in it?: {0}'.format(self.PresentRoot))
                Question('Continue?')

        # TestRoot should be below RunRoot
        if not isBelowDir(self.RunRoot,self.TestRoot):
            Error('TestRoot must be under RunRoot')
        # Only check these once!
        self.NoCheck = True

    def presentRoot(self,testRoot=None):
        '''Returns (html) presentation directory for a case with root=testRoot.
        If called without args, returns toplevel directory, PresentRoot'''
        if testRoot is None:
            return self.PresentRoot
        fullPath = os.path.realpath(testRoot)
        tpL = len(self.TestRoot)
        relativeTestRoot = fullPath[tpL:]
        return os.path.join(self.PresentRoot,relativeTestRoot.lstrip('/'))

    def mkPresentRoot(self,testRoot):
        '''Create and return path to tests presentation directory'''
        pRoot = self.presentRoot(testRoot)
        # Since removing recursively/dangerously, check if we are in the
        # Results tree else abort! (Shoud never happen, but...)
        if not isBelowDir(self.presentRoot(), pRoot):
            Error('Some error. {0} should be below {1}'.format(pRoot,self.PresentRoot))
        try:
            Debug('Present root ='+pRoot)
            if os.path.exists(pRoot): # FIXME not safe could remove home...:-|
                Debug('Removing all files in {0}'.format(pRoot))
                (os.remove(f) for f in os.listdir(pRoot))
            else:
                os.makedirs(pRoot)
        except:
            Error('Cannot create presentation root dir {0}'.format(pRoot))
        return pRoot


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def Info(astring):
    print '>>',astring

def Debug(astring):
    if Paths(noCheck=True).Debug:
        Info('DEBUG: '+astring)
    return

def Error(s=''):
    import inspect
    errFile = inspect.stack()[1][1]
    errLine =  inspect.stack()[1][2]
    errCaller = inspect.stack()[1][3]
    print 'Error() called from Function {0}\nin {2} line {1}'.format(errCaller,errLine,errFile)
    print 'ERROR:',s
    sys.exit(1)

def Question(s='', cont='yes'):
    ans = raw_input('QUESTION: '+s+'. Press '+ cont +' to continue: ')
    if ans == cont:
        pass
    else:
        Error('Quiting, since received '+ans+' and not '+cont)
    return ans

def Warning(s=''):
    print 'WARNING:',s

def leastCommonPath(p1,p2):
    import os
    def do(a1,a2):
        lcp = []
        for i,item in enumerate(a1):
            if item == a2[i]:
                lcp.append(item)
            else:
                break
        return os.path.join(*lcp)

    sp1 = os.path.realpath(p1).split(os.sep)
    sp2 = os.path.realpath(p2).split(os.sep)
    common = do(sp1,sp2) if len(sp2)>len(sp1) else do(sp2,sp1)
    return os.path.sep+common

def isBelowDir(p1,p2):
    commonPath=leastCommonPath(p1,p2)
    return (p1 == commonPath)

def cleanPostProcessingData(postProcessingFile):
    """Cleans e.g. forces files from parentheses and comments.
    Returns a list of strings void of parentheses (etc)"""
    import string
    stringList = None
    if not os.path.isfile(postProcessingFile):
        Error('Cannot read data file {0}'.format(postProcessingFile))
    with open(postProcessingFile,'r') as fp:
        stringList = fp.readlines()
    dropPat = re.compile('^\s*(?![\(\)\#"\/a-zA-Z])')
    parenPat = re.compile('[,\(\)]')
    filtered = filter(dropPat.match, stringList)
    filtered = [parenPat.sub(' ',a) for a in filtered]
    return map(string.strip,filtered)

def findFiles(startRoot, patternString, dirname=False, unique=False):
    '''Return dirs or file paths containing file matching patternString.
    If dirname=True containing dir is returned, otherwise the matching
    file path. unique only speeds up the search...?'''
    import re
    pat = re.compile(patternString)
    paths = []
    for root, dirs, files in os.walk(startRoot):
        for f in files:
            if pat.match(f):
                if dirname:
                    paths.append(root)
                    break
                else:
                    paths.append(os.path.join(root,f))
                    if unique: break
    return list(set(paths)) # Just in case there are still duplicates...

def findDirs(startRoot, patternString, dirname=False, unique=False):
    '''Return dirs containing dir matching patternString. If dirname=
    True containing dir is returned, otherwise the matching dir path.
    unique only speeds up the search...?'''
    import re
    pat = re.compile(patternString)
    paths = []
    for root, dirs, files in os.walk(startRoot):
        for d in dirs:
            if pat.match(d):
                if dirname:
                    paths.append(root)
                    break
                else:
                    paths.append(os.path.join(root,d))
                    if unique: break
    return list(set(paths)) # Just in case there are still duplicates...


if __name__=='__main__':

    files = findFiles('/tmp/testSuite','caseB.*',dirname=False)
    folders=findFiles('/tmp/testSuite','caseB.*',dirname=True)

    for item in files:
        print item

    print

    for item in folders:
        print item

    print 'Present root'

    tr = os.getcwd()

    p1 = Paths(testRoot = tr, presentRoot = sys.argv[1])

    p2 = Paths()

    print p1.presentRoot(tr+'/rasTests/case0')

    p2.PresentRoot = '/tmp/tests2'

    print p1.presentRoot(tr+'/lesTests/case0')
    print p2.presentRoot(tr+'/lesTests/case1')
