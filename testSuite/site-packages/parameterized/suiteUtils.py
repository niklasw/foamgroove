#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os,sys,glob,re

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class Borg:
    '''Hivemind base class. Google "python borg singleton" '''
    _shared_state = {}
    def __init__(self):
        self.__dict__ = self._shared_state

class Paths(Borg):
    '''By subclassing Borg, this class variables are common to
    all instances of Path(), in the main process.
    Note that Paths try to convert all paths to realpaths.

    Should perhaps make all classes that use configuration generated
    in Paths inherit Borg as well, which should make configuration
    builtin...
    '''
    SubCasePrefix = 'subCase_'
    SubCasePattern = r'{0}.*'.format(SubCasePrefix)
    TestSummaryFileName  = 'testSummary'

    def __init__(self, testRoot=None, presentRoot=None, noCheck=False):
        '''First instance of this class must define the paths, then Paths
        can then be instantiated without arguments; Thus the kwargs None
        and the if statements below'''
        Borg.__init__(self)
        if testRoot:
            self.TestRoot = os.path.realpath(testRoot) # Top level test root
        if presentRoot:
            self.PresentRoot = os.path.realpath(presentRoot) # Top level presentation root
        else:
            self.PresentRoot = None
            self.SkipPresentation = True
            self.SkipPost = True
        if 'RunRoot' not in self.__dict__:
            self.RunRoot = os.getcwd()
        if 'SkipPresentation' not in self.__dict__:
            self.SkipPresentation = False
        if 'SkipPost' not in self.__dict__:
            self.SkipPost = False
        if 'SkipRun' not in self.__dict__:
            self.SkipRun = False
        if 'DeleteSubCases' not in self.__dict__:
            self.DeleteSubCases = True
        if 'ParameterFile' not in self.__dict__:
            self.ParameterFile = None
        if 'nThreads' not in self.__dict__:
            self.nThreads = 1
        if 'Debug' not in self.__dict__:
            self.Debug = False
        if 'NoCheck' not in self.__dict__:
            self.NoCheck = noCheck
        if 'Jinja' not in self.__dict__:
            self.Jinja = False

        if not self.NoCheck:
            self.assertRoots()

    def assertRoots(self):
        def checkRoot(root):
            try:
                attribute = getattr(self,root)
                if not os.path.isdir(self.TestRoot):
                    Error('{0} does not exist: {1}'.format(root,attribute))
            except(AttributeError):
                Error('Missing path in Paths: {0}'.format(root))

        checkRoot('TestRoot')
        if not self.SkipPresentation:
            checkRoot('PresentRoot')
            if os.path.isdir(self.PresentRoot):
                Warning('PresentRoot exists, do you want to mess in it?: {0}'.format(self.PresentRoot))
                Question('Continue?')

        # TestRoot should be below RunRoot
        if not isBelowDir(self.RunRoot,self.TestRoot):
            Error('TestRoot must be under RunRoot')
        # Only check these once!
        self.NoCheck = True

    def presentRoot(self,testRoot):
        fullPath = os.path.realpath(testRoot)
        tpL = len(self.TestRoot)
        relativeTestRoot = fullPath[tpL:]
        return os.path.join(self.PresentRoot,relativeTestRoot.lstrip('/'))

    def mkPresentRoot(self,testRoot):
        '''Create and return path to tests presentation directory'''
        pRoot = self.presentRoot(testRoot)
        # Since removing recursively/dangerously, check if we are in the
        # Results tree else abort! (Shoud never happen, but...)
        if not isBelowDir(self.PresentRoot, pRoot):
            Error('Some error. {0} should be below {1}'.format(pRoot,self.PresentRoot))
        try:
            Debug('Present root ='+pRoot)
            if os.path.exists(pRoot): # FIXME not safe could remove home...:-|
                Debug('Removing all files in {0}. IS THIS UNSAFE?!'.format(pRoot))
                for f in os.listdir(pRoot):
                    rmfile=os.path.join(pRoot,f)
                    os.remove(rmfile)
            else:
                os.makedirs(pRoot)
        except:
            Error('Cannot create presentation root dir {0}'.format(pRoot))
        return pRoot


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class postCommand:
    def __init__(self,executable='pvbatch',argList=['--no-mpi','--force-offscreen-rendering']):
        self.exe = executable
        self.args = argList

    def findExe(self):
        from distutils import spawn
        if spawn.find_executable(self.exe):
            return True
        else:
            return False

    def command(self,script):
        return [self.exe] + self.args + [script]

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def Info(astring):
    print('>>',astring)

def Debug(astring):
    if Paths(noCheck=True).Debug:
        import inspect
        errFile = inspect.stack()[1][1]
        errLine =  inspect.stack()[1][2]
        errCaller = inspect.stack()[1][3]
        dstr = ('Debug() called from Function {0} in {2} line {1}'.format(errCaller,errLine,errFile))
        Info(dstr+':\n\t'+astring)
    return

def Error(s=''):
    import inspect
    errFile = inspect.stack()[1][1]
    errLine =  inspect.stack()[1][2]
    errCaller = inspect.stack()[1][3]
    print('Error() called from Function {0}\nin {2} line {1}'.format(errCaller,errLine,errFile))
    print('ERROR:',s)
    sys.exit(1)

def Question(s='', cont='yes'):
    ans = input('QUESTION: '+s+'. Press '+ cont +' to continue: ')
    if ans == cont:
        pass
    else:
        Error('Quiting, since received '+ans+' and not '+cont)
    return ans

def Warning(s=''):
    print('WARNING:',s)

def leastCommonPath(p1,p2):
    import os
    def do(a1,a2):
        lcp = []
        for i,item in enumerate(a1):
            if item == a2[i]:
                lcp.append(item)
            else:
                break
        return os.path.join(*lcp)

    sp1 = os.path.realpath(p1).split(os.sep)
    sp2 = os.path.realpath(p2).split(os.sep)
    common = do(sp1,sp2) if len(sp2)>len(sp1) else do(sp2,sp1)
    return os.path.sep+common

def isBelowDir(p1,p2):
    commonPath=leastCommonPath(p1,p2)
    return (p1 == commonPath)

def pathTail(path,n):
    d=path
    tail=[]
    for i in range(n):
        d,r=os.path.split(d)
        tail.append(r)
        if len(d) == 1:
            break
    tail = tail[::-1]
    return os.path.join(*tail)

def excludeDir(name):
    excludes = ['processor', '.git', '.svn']
    for excl in excludes:
        if excl in name:
            return True
    return False

def findFiles(startRoot, patternString, dirname=False, unique=False,topdown=True):
    '''Return dirs or file paths containing file matching patternString.
    If dirname=True containing dir is returned, otherwise the matching
    file path. unique only speeds up the search...?'''
    import re
    pat = re.compile(patternString)
    paths = []
    for root, dirs, files in os.walk(startRoot):
        dirs[:] = [ item for item in dirs if excludeDir(item) ]
        for f in files:
            if pat.match(f):
                if dirname:
                    paths.append(root)
                    break
                else:
                    paths.append(os.path.join(root,f))
                    if unique: break
    return list(set(paths)) # Just in case there are still duplicates...

def findDirs(startRoot, patternString, dirname=False, unique=False,topdown=True):
    '''Return dirs containing dir matching patternString. If dirname=
    True containing dir is returned, otherwise the matching dir path.
    unique only speeds up the search...?'''
    import re
    pat = re.compile(patternString)
    paths = []
    for root, dirs, files in os.walk(startRoot):
        dirs[:] = [ item for item in dirs if not excludeDir(item)]
        for d in dirs:
            if pat.match(d):
                if dirname:
                    paths.append(root)
                    break
                else:
                    paths.append(os.path.join(root,d))
                    if unique: break
    return list(set(paths)) # Just in case there are still duplicates...


if __name__=='__main__':

    files = findFiles('/tmp/testSuite','caseB.*',dirname=False)
    folders=findFiles('/tmp/testSuite','caseB.*',dirname=True)

    for item in files:
        print(item)

    print()

    for item in folders:
        print(item)

    print('Present root')

    tr = os.getcwd()

    p1 = Paths(testRoot = tr, presentRoot = sys.argv[1])

    p2 = Paths()

    print(p1.presentRoot(tr+'/rasTests/case0'))

    p2.PresentRoot = '/tmp/tests2'

    print(p1.presentRoot(tr+'/lesTests/case0'))
    print(p2.presentRoot(tr+'/lesTests/case1'))
