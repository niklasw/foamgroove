#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, glob, re
from .suiteUtils import Info, Error, Debug, Warning, Paths,findFiles,findDirs,findDirs,excludeDir
from .caseBook import Book

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class FoamCase:
    '''
    A FoamCase can be either the template base case or a sub-case.
    Generates sub-cases but needs CaseManager to de-templify them.
    Files matching any of the skipNames are not copied to subCases, whereas
    the same files AND files starting with __ are not treated as templates;
    Thus, to have template-like strings un-touched in a subCase, prefix the
    name with __.
    '''

    def __init__(self,caseRoot,skipNames=['.*subCase_.*',
                                          '.*\.test',
                                          '.*.html',
                                          '.*\.?log',
                                          '.*\.json',
                                          '.*html.*',
                                          '.*\.git.*',
                                          '.*auxiliary.*']):
        self.root = caseRoot
        skipNames.append(Paths.SubCasePattern)
        if Paths().PresentRoot:
            skipNames.append(os.path.basename(Paths().PresentRoot))
        self.skipNames = skipNames
        self.skipNames.append('.*{0}.*'.format(Paths.SubCasePrefix))
        self.skipPatterns = [ re.compile(p) for p in skipNames ]
        self.fileList = list(self.getFileTreeList())
        #self.subRoots = findDirs(self.root,Paths.SubCasePattern,unique=True)
        self.subRoots = findDirs(self.root,Paths.SubCasePattern)
        self.name = os.path.split(caseRoot)[-1]
        self.parameters = {}

    def getTestFiles(self):
        '''If the option parameterfile is selected, return a list with
        the single parameter file only, else return a list with
        all parameter files in the case root.'''
        return [Paths().ParameterFile] \
                if Paths().ParameterFile \
                else findFiles(self.root,'.*\.json$')

    def getFileTreeList(self):
        def filterNames(fileNames):
            for p in self.skipPatterns:
                fileNames = [ f for f in fileNames if not p.match(f) ]
            fileNames = [ f for f in fileNames if not f[0:2] == '__']
            return fileNames

        for root,dirs,files in os.walk(self.root,topdown=True):
            dirs[:] = [d for d in dirs if not Paths.SubCasePrefix in d]
            dirs[:] = [d for d in dirs if not excludeDir(d)]
            for f in filterNames(files):
                fPath = os.path.join(root,f)
                yield fPath

    def clean(self):
        import shutil
        if not Paths().SkipRun and Paths().DeleteSubCases:
            Info("DELETE: Cleaning all sub cases")
            for subCase in self.subRoots:
                shutil.rmtree(subCase)

    def mkSubCase(self):
        '''Create a copy of this case,avoiding to duplicate files
        matching patterns in self.skipNames. Also avoiding already
        present subRoots.'''
        import shutil
        subCaseName = '{0}{1:03d}'.format(Paths.SubCasePrefix,len(self.subRoots))
        subCaseRoot = os.path.join(self.root,subCaseName)

        # Fun way to return false if path matches none of the skipPatterns
        keepMe = lambda f: all([not p.match(f) for p in self.skipPatterns])
        caseContent = [a for a in os.listdir(self.root) if keepMe(a)]

        os.mkdir(subCaseRoot)

        for item in caseContent:
            source = os.path.join(self.root,item)
            target = os.path.join(subCaseRoot,item)
            if os.path.isdir(source):
                shutil.copytree(source,target)
            else:
                shutil.copy(source,target)
        self.subRoots.append(subCaseRoot)
        return FoamCase(subCaseRoot)

    def annotate(self,astring):
        with open(os.path.join(self.root,'caseParameters'),'a') as fp:
            fp.write('{0}\n'.format(astring))

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class CaseManager:
    '''
    Manager of subCases. Responsible for setting the parameters based on a
    given Parameter dictionary.
    Instantiated by TestRunner who manages the params.
    Contain all methods for running and processing a subCase and authors the
    book of a subCase.
    '''

    def __init__(self,foamCase,config):
        self.config = config
        self.case = foamCase
        self.book = Book(foamCase.root)
        self.nCores = 1
        self.mpiParams = ''

    def setParameters(self,parametersDict):
        from string import Template
        from jinja2 import Template as Jinja
        self.parameters = parametersDict
        self.book.parameters = parametersDict

        for value in list(parametersDict.values()):
            self.case.name += '__'+str(value)
        result = ''
        for f in self.case.fileList:
            with open(f,'r') as fp:
                if Paths().Jinja:
                    try:
                        jinjaTpl = Jinja(fp.read())
                        result = jinjaTpl.render(**parametersDict)
                    except Exception as e:
                        Warning(f'Could not read {f}. Skipping.')
                        continue
                else:
                    try:
                        tpl = Template(fp.read())
                        result = tpl.safe_substitute(**parametersDict)
                    except Exception as e:
                        print(e)
                        Error(f'Could not read {f}')
            with open(f,'w') as fp:
                fp.write(result)
        for parameter,value in parametersDict.items():
            self.case.annotate('{0}:{1}'.format(parameter,value))

        if '__ncores' in parametersDict:
            self.nCores = parametersDict['__ncores']

        if '__mpiparams' in parametersDict:
            self.mpiParams = parametersDict['__mpiparams']

    def runCommand(self,name='Noname',cmd='',writeToBook = True):
        """Call command through Popen and store data
        in 'Book'
        Tedious to open files to write to and then read back into out
        and err, but cannot figure out how to do it otherwise if logging
        to be written while process runs"""
        import subprocess,time
        startT = time.time()
        Debug(str(cmd))

        logFile = open('{0}/{1}.stdout'.format(self.case.root,name),'a+')
        errFile = open('{0}/{1}.stderr'.format(self.case.root,name),'a+')

        p = subprocess.Popen(cmd,                    \
                             stdout=logFile, \
                             stderr=errFile, \
                             cwd=self.case.root,     \
                             shell=False)
        status =  p.wait()
        elapsedT = time.time()-startT

        logFile.seek(0)
        errFile.seek(0)
        out = logFile.read()
        err = errFile.read()
        errFile.close()
        logFile.close()

        if writeToBook:
            # Write output messages in the Book
            self.book.timer[name] = elapsedT
            self.book.logData[name] = out
            self.book.errData[name] = err
            self.book.exitStatus[name] = status
        if status != 0 and Paths().Debug:
            print('Error message from CaseManager.runCommand follows\n{0}'.format(err))
        return (out,err,status,elapsedT)

    def runScript(self, script_name):
        script = os.path.join(self.case.root, script_name)
        if os.path.isfile(script):
            name = os.path.splitext(script_name)[0]
            self.runCommand(cmd=[script],name=name)
            return True
        else:
            return False

    def preProcess(self):
        self.runScript('prepare.sh')

    def runWithScript(self):
        self.runScript('run.sh')

    def run(self):
        if not self.runWithScript():
            cmd = []
            if self.nCores > 1:
                cmd.extend(['mpirun','-np',str(self.nCores)])
                if self.mpiParams:
                    cmd.extend(self.mpiParams.split())
                cmd.extend([self.config.solver,'-parallel'])
            else:
                cmd.append(self.config.solver)
            runCmd = ' '.join(cmd)
            self.runCommand(cmd=cmd,name='run')

    def finalise(self):
        if self.nCores > 1 and self.config.reconstruct:
            self.runCommand(cmd=['reconstructPar'],name='reconstruct')
        script = os.path.join(self.case.root,'finalise.sh')
        if os.path.isfile(script):
            self.runCommand(cmd=[script],name='finalise')

        # Need to write book to disk now, so post processing can add to it.
        # The post processing app, in turn, should open the book from file
        # in order to add pictures and data tables etc.
        self.book.close()

    def postProcess(self):
        if Paths().SkipPost:
            Warning('No post processing performed.')
            return
        script = os.path.join(self.case.root,'post.py')
        command = ['pvbatch','--no-mpi','--force-offscreen-rendering',script]
        #command = ' '.join(command)
        out,err,status,etime = self.runCommand(cmd=command,writeToBook=False)

        # Need to re-open Book to write post process run data to it, since
        # it was closed for external app writing by finalise()
        self.book = Book.open(self.case.root)
        self.book.logData['postProcess'] = out
        self.book.errData['postProcess'] = err
        self.book.exitStatus['postProcess'] = status
        self.book.timer['postProcess'] = etime

    def do(self):
        import shutil
        if not Paths().SkipRun:
            self.preProcess()
            self.run()
            self.finalise()
            self.postProcess()
        self.book.present()

        if Paths().DeleteSubCases:
            Debug('DELETE {0}'.format(self.case.root))
            shutil.rmtree(self.case.root)
        return True

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
