#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os,sys,glob,re
from parameterized.suiteUtils import Info,Warning,Error,Debug,Paths
from parameterized.caseManaging import FoamCase, CaseManager
from parameterized.caseBook import Book

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class ParamDict(dict):
    ''' Read test config and create parameter matrix from json file.
    config file example:

    {
        "comment1": "Normal comments are not allowed in JSON",
        "comment2": "but comments can be hidden like this...",

        "parameters": {
            "__les_model": [ "SMG", "Smagorinsky" ],
            "__wall_model": [ "nutUSpaldingWallFunction", "zeroGradient" ]
        },
        "groups": {
            "g1": ["__les_model","__wall_model"]
        },
        "solution": {
            "master": "okkotto" //NOT_IMPLEMENTED
            "qsubFile": "qrun.qsub" //NOT_IMPLEMENTED
            "nprocs": 1,
            "solver": "pimpleFoam"
        }
    }
    '''

    mandatorySections_ = ['solution','parameters']

    def __init__(self,fileName):
        import json
        if not os.path.isfile(fileName):
            Error('Fatal: missing test file')
        dict.__init__(self,json.load(open(fileName)))
        self.fileName = fileName
        self._check()

        self.parameters = self.get('parameters')

        general = self.get('solution')
        self.solver = general.get('solver')

        if 'ncores' in general:
            # Legacy handling
            Warning('Parameter file handling changed wrt ncores. Set __ncores as a parameter only.')
        if '__ncores' not in self.parameters:
            Warning('No parameter __ncores found. Case will run on single core')

        if 'reconstruct' in general:
            self.reconstruct = general.get('reconstruct')
        else:
            self.reconstruct = True
        # List of groups. Discard the keys. Groups are optional.
        if 'groups' in self:
            self.groups = list(self.get('groups').values())
        else:
            self.groups = []

        self.isGrouped = self.checkGroups()

    def _check(self):
        for ms in self.mandatorySections_:
            if not ms in list(self.keys()):
                Error('Fatal: missing section in JSON configuration: {0}'.format(ms))

    def checkGroups(self):
        # Check that groups contain valid parameter names,
        # that they appear only once, and that number of values matches
        params = list(self.parameters.keys())
        isGrouped = dict(list(zip(params, len(params)*[False])))
        for g in self.groups:
            if(len(g) < 2):
                Error('Fatal: group has fewer than two entries.')
            for param in g:
                if(not param in params):
                    Error('Fatal: unknown parameter name in group: {0}'.format(param))
                if(isGrouped.get(param)):
                    Error('Fatal: Parameter appears in more than one group: {0}'.format(param))
                isGrouped[param] = True
            l = [len(self.parameters.get(p)) for p in g ]
            if not l or not l.count(l[0]) == len(l):
                Error('Fatal: Grouped parameters have different number of values.')
        return isGrouped

    def parameterMatrix(self):
        import itertools
        keyValuePairs = list()

        # Add grouped parameters first as single large tuple
        for g in self.groups:
            groupParamVals = None
            for param in g:
                values = self.parameters.get(param)
                paramVals = None
                if isinstance(values,list):
                    paramVals = list(zip(len(values)*[param],values))
                else:
                    paramVals = [(param,values)]
                if isinstance(groupParamVals,list):
                    groupParamVals = [a + b for (a,b) in zip(groupParamVals,paramVals)]
                else:
                    groupParamVals = paramVals
            keyValuePairs.append(groupParamVals)

        # Now add non-grouped parameters
        for param,values in self.parameters.items():
            if not self.isGrouped[param]:
                paramVals = None
                if isinstance(values,list):
                    paramVals = list(zip(len(values)*[param],values))
                else:
                    paramVals = [(param,values)]
                keyValuePairs.append(paramVals)

        # Found this on da google...
        # To create an iterable of all combinations
        matrix = itertools.product(*keyValuePairs)

        for row in matrix:
            # Expand all grouped parameters to pairs
            rowExpand = list()
            for entry in row:
                for i in range(0,len(entry),2):
                    rowExpand.append((entry[i], entry[i+1]))
            print(rowExpand)
            yield dict(rowExpand)

class TestRunner:
    '''
    A Test is defined as one base case that can have several .json files.
    The TestRunner creates the parameter dict for each test and creates
    CaseManagers which manipulate and run all sub-cases in a test.
    '''

    def __init__(self,caseRoot,nThreads=1):
        self.case = FoamCase(caseRoot)
        self.case.clean()
        self.nThreads = nThreads
        self.currentConfig = None
        self.testSummaryFile = None

    def readConfig(self,testFile):
        '''Need to separate this and carry currentConfig,
           in order to use a generator for test series'''
        self.currentConfig = ParamDict(os.path.join(self.case.root, testFile))

    def generateTests(self):
        '''Yield a manager for every row in the parameter matrix.
        Note: This is a generator. Must be looped for anyting to happen.
        '''

        for parameterSet in self.currentConfig.parameterMatrix():
            subCase = self.case.mkSubCase()
            worker = CaseManager(subCase, self.currentConfig)
            worker.setParameters(parameterSet)
            yield worker

    def runTests(self,testFile):
        from multiprocessing import Process
        Info('Running test file {0}'.format(testFile))
        self.readConfig(testFile)
        testGenerator = self.generateTests()
        allDone = False

        testFileNamePrefix = os.path.splitext(self.currentConfig.fileName)[0]
        self.testSummaryFile = \
            open(os.path.join(self.case.root,'.'.join([testFileNamePrefix,Paths().TestSummaryFileName])),'w')

        testSummaryList = []
        while not allDone:
            pss = []
            for i in range(self.nThreads):
                try:
                    worker = next(testGenerator)
                    testSummaryList.append(worker.book.summaryString())
                except Exception as e:
                    print(e)
                    allDone = True
                    break
                ps = Process(target=worker.do)
                pss.append(ps)
                ps.start()
                Info('Started process {0}: {1}'.format(i,worker.case.name))

            # Wait for processes to end
            for i,ps in enumerate(pss):
                ps.join()

            self.testSummaryFile.write('\n'.join(testSummaryList)+'\n')

            Debug('\tAll threads done')

    def runAllTestFiles(self):
        for testFile in self.case.getTestFiles():
            self.runTests(testFile)

    def collectBooks(self):
        '''Iter return a Book, read from each subcase's presentation dir'''
        from .suiteUtils import findFiles
        pRoot = Paths().presentRoot(self.case.root)
        bookPaths = findFiles(pRoot,Book.dbFile,dirname=True)
        bookPaths.sort()
        for root in bookPaths:
            yield Book.open(root)

    def createTestTable(self):
        from .htmlUtils import htmlTable, htmlLink
        Info('Creating test table for {0}'.format(self.case.root))
        tableRows = []
        heads = ['Name','Status','Parameters','Time']
        for caseBook in self.collectBooks():
            summary = caseBook.summaryDict()
            linkPath = os.path.join(caseBook.presentRoot(),'index.html')
            caseLink = htmlLink(summary['name'],linkPath)
            row = [caseLink, summary['status'],caseBook.parameterString('<br/>'), \
                   summary['time']]
            tableRows.append(row)
        # Use id 'filtertable' to match javascript table id for FilterTable.js
        return htmlTable(tableRows,heads,ID='filtertable')

    def printHtml(self):
        from .htmlUtils import htmlDiv,htmlTemplate,htmlSection,htmlList
        from .htmlTemplates import basicHtmlJS as template
        div = htmlDiv(cls='test_table')

        header = htmlSection(self.case.name,self.case.root,level=1)
        testTable = self.createTestTable()

        div.append(header.content)
        div.append(testTable.content)
        div.update()

        presentRoot = Paths().presentRoot(self.case.root)
        doc = htmlTemplate(template,root=presentRoot, \
                           relRoot=Paths().PresentRoot)
        doc.addContent(content1=div.content)

        return doc.content

    def writeHtml(self):
        from .htmlTemplates import fileCopy
        presentRoot = Paths().presentRoot(self.case.root)
        if os.path.isdir(presentRoot):
            Debug('Writing index.html to {0}'.format(presentRoot))
            with open(os.path.join(presentRoot,'index.html'),'w') as fp:
                fp.write(self.printHtml())
            fileCopy('tablefilter.js',presentRoot)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class SuiteRunner:
    '''
    Finds all .json files under TestRoot, creates a TestRunner for each
    test file. Does all run and present calls to TestRunner.
    '''

    def __init__(self, root):
        self.root = os.path.realpath(root)
        if not os.path.isdir(self.root):
            Error('Not a directory: {0}'.format(self.root))
        self.tests = self.findTests()
        if not self.tests:
            Info('No tests found.')

    def findTests(self):
        '''If the option parameterfile is selected, return a list with
        the single path to the TestRoot only, else return a list with
        all directories under TestRoot, containing parameter file(s)'''
        from parameterized.suiteUtils import findFiles

        return [self.root] \
                if Paths().ParameterFile \
                else findFiles(self.root,'.*\.json\s*$',dirname=True)

    def run(self, nThreads = 1):
        for root in self.tests:
            Info(root)
            Test = TestRunner(root, nThreads)
            Test.runAllTestFiles()

    def present(self):
        from .htmlUtils import htmlTree
        from .htmlTemplates import basicHtml as template
        if Paths().SkipPresentation:
            Info('Presentation skipped')
            return
        for root in self.tests:
            Test = TestRunner(root)
            Test.writeHtml()
        # Create the tree of recursive index.html files
        htTree = htmlTree(Paths().PresentRoot, \
                          Paths().SubCasePattern,template)
        htTree.makeIndexTree()


if __name__=='__main__':
    if not len(sys.argv) > 1:
        Error('Path to tests top level as sole argument needed')

    Suite = SuiteRunner(sys.argv[1])
    for root in Suite.tests:
        Info(root)
        Test = TestRunner(root)

        print('Test.case.root:',Test.case.root)

        testFiles = Test.case.getTestFiles()

        for testFile in testFiles:
            config = ParamDict(os.path.join(Test.case.root, testFile))
            matrix = config.parameterMatrix()
            Info('Test matrix from test file {0}:'.format(testFile))
            for parameterSet in matrix:
                print(parameterSet)
